---
title: Usando dcast y setnames **dentro** de una data.table
author: Giovanni Pavolini
date: '2019-11-05'
slug: usando-dcast-y-setnames-dentro-de-una-data-table
categories:
  - Spanish
tags:
  - data.table
---

Yo he dicho antes que una de las mejores cosas de `data.table` es que **J** acepta expresiones y no sÃ³lo funciones. Eso ofrece mucha flexibilidad respecto de lo que uno puede lograr con su cÃ³digo.


TmabiÃ©n, el hecho de que `.SD` sea una data.table permite usar **dentro de una data.table** algunas funciones que aparentemente deberÃ­an usarse fuera de ella.

Vea por ejemplo `dcast`, la funciÃ³n usada para convertir una data.table de larga a ancha. EstÃ¡ hecha para ser usada **sobre** una data.table, no **dentro** de ella, Â¿cierto?

Â¿Y quÃ© tal `setnames`? Â¡Si estÃ¡ diseÃ±ada para cambiar los nombres de una data.table, entonces definitivamente debe ser usada fuera de una!

Bueno, Â¡no tanto! Ambas funciones pueden ser usadas para lograr algunas cosas interesantes **dentro** de una data.table. Yo replicarÃ© un caso de uso que me encontrÃ© ayer que ilustrarÃ¡ como usar ese tipo de funciones dentro de una data.table.


## Analizando ventas
Imagine que usted tiene un set de datos con las transacciones realizadas por un equipo de ventas. La table tiene la fecha de la transacciÃ³n, la cantidad e item cubiertos en la transacciÃ³n y el nombre de la persona de ventas responsable por ella. Ahora, la cantidad puede ser negativa, y en ese caso eso significa que es una _devoluciÃ³n_. Nosotros queremos calcular el porcentaje de devoluciones de cada persona de ventas.


### Construyendo algunos datos de Ejemplo
Construyamos los datos de ejemplo:

```{r}
library(data.table)

set.seed(1)

fechas <- seq(as.Date("2019-01-01"), 
             as.Date("2019-10-31"), 
             by = "1 day")

vendedores <- c("Jose", "Maria", 
               "Pedro", "Roberto", 
               "Alicia", "Juan", "Susana")

items <- data.table(item = LETTERS[1:20], 
                    precio = sample(1:20))

ventas <- data.table(fecha = sample(fechas, 200, TRUE), 
                    cant = sample(-20:100, 200, TRUE), 
                    item = sample(LETTERS[1:20], 200, TRUE), 
                    vendedor = sample(vendedores, 200, TRUE), 
                    key = "fecha")

ventas[items, pesos := cant * precio, on = .(item)]

ventas
```

### Generando la LÃ³gica
Hay varias formas de calcular el porcentaje de devoluciones de cada vendedor, pero ya que esto es sÃ³lo una excusa para mostar una capacidad chÃ©vere de `data.table`, les propondrÃ© una lÃ³gica que podrÃ­a no ser la Ã³ptima. Usaremos la siguiente receta:

1. Encontrar cuales transacciones son devoluciones y cuales no.
2. Agrupar por vendedor **y por** el tipo de transacciÃ³n (devoluciÃ³n o no).
3. Sumar el valor en pesos de las transacciones y finalmente
4. Calcular el cociente de devoluciones a ventas y multiplicarlo por 100 para tener el porcentaje.

Idealmente terminaremos con algo como esto:


```{r, echo = FALSE}
knitr::kable(data.frame("Juan", 
                        20, 100, 
                        "20 / 100 = 20%"), 
             col.names = c("Vendedor", "Devoluciones", 
                           "Ventas", "Devoluciones %"))
```

### Haciendo que suceda
Encontrar quÃ© transacciones son devoluciones es fÃ¡cil: nos dijeron que son aquellas con cantidades negativas. Las podrÃ­amos marcar como devoluciones, o podrÃ­amos ir directo con esa validaciÃ³n en la parte `by = ` de la data.table. Vamos a usar la segunda opciÃ³n:


```{r}
ventas[, sum(pesos), by = .(devolucion = cant < 0)]
```

Este resultado tiene el problema de no integrar al vendedor y tambiÃ©n de tener pesos negativos, asÃ­ que vamos a arreglarlos:

```{r}
ventas[, abs(sum(pesos)), 
      by = .(vendedor, 
             devolucion = cant < 0)]
```

Ahora, esto es mucho mejor, _pero es una tabla larga_. PodrÃ­amos avanzar de aquÃ­ asignando el comando previo a una nueva data.table, haciÃ©ndole `dcast` y luego calculando el porcentaje. **Pero en realidad lo podemos hacer dentro de la data.table**:


```{r}
ventas[, abs(sum(pesos)), 
      by = .(vendedor, 
             devolucion = cant < 0)][, 
                                dcast(.SD, 
                                      vendedor ~ devolucion, 
                                      fill = 0, 
                                      value.var = "V1")]
```

Wow! Eso definitivamente se parece a la tabla que querÃ­amos. Veamos quÃ© pasÃ³ en el comando encadenado:

+ `dcast(.SD, vendedor ~ devolucion, fill = 0, value.var = "V1")`
    + `.SD` es una data.table. De hecho, es **nuestra**ote que el _scope_  de la data.table permanece como es habitual: reconoce los nombres en los datos.
    + `fill = 0` es simplemente derivado de la naturaleza del caso a la mano: si un vendedor no tuvo devoluciones (o ventas), eso significa que sus devoluciones (o ventas) fueron cero, no "no disponible".
    + y `value.var` es algo que uso principalmente para quitarme el mensaje ğŸ¤·.
    
PodrÃ­amos avanzar desde aquÃ­, trabajando con  `FALSE` y `TRUE` como nombres de columnas (ellos son nombres vÃ¡lidos en tanto que se usen los back ticks cuando se llaman), pero eso es en realidad engorroso. AsÃ­ que, Â¿quÃ© tal renombrar las columnas?

Por supuesto, `setnames` viene a la mente, pero esa funciÃ³n es frecuentemente usada _fuera_ de una data.table, Â¿o no?

Veamos:

```{r}
ventas[, abs(sum(pesos)), 
      by = .(vendedor, 
             devolucion = cant < 0)][, 
                                dcast(.SD, 
                                      vendedor ~ devolucion, 
                                      fill = 0, 
                                      value.var = "V1")][,
                                                         setnames(.SD, 
                                                                  2:3, 
                                                                  c("ventas", "devoluciones"))]
```

Ahora es simplemente usar el operador de asignaciÃ³n `:=` para definir el porcentaje:

```{r}
ventas[, abs(sum(pesos)), 
      by = .(vendedor, 
             devolucion = cant < 0)][, 
                                dcast(.SD, 
                                      vendedor ~ devolucion, 
                                      fill = 0, 
                                      value.var = "V1")][,
                                                         setnames(.SD, 
                                                                  2:3, 
                                                                  c("ventas", "devoluciones"))][,
                                                                                          porcentaje := 100 * devoluciones / ventas][order(-porcentaje)]
```

Â¡Eso es exactamente lo que esperÃ¡bamos!

## LÃ­nea de cierre
Es posible usar funciones dentro de una data.table, aÃºn si ellas aparentemente fueron pensadas para ser usadas fuera de ella. Las claves para lograrlo son mantener en mente que `.SD` es en sÃ­ misma una data.table que guarda el resultado del Ãºltimo comando encadenado y tambiÃ©n que **J** (y by =) aceptan no sÃ³lo funciones, sino expresiones.

