<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>English on Giovanni Pavolini - Consultor</title>
    <link>https://gpavolini.netlify.com/categories/english/</link>
    <description>Recent content in English on Giovanni Pavolini - Consultor</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 21 Nov 2019 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://gpavolini.netlify.com/categories/english/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>data.table joins: is X[Y] or Y[X]?</title>
      <link>https://gpavolini.netlify.com/blog/data-table-joins-is-x-y-or-y-x/</link>
      <pubDate>Thu, 21 Nov 2019 00:00:00 +0000</pubDate>
      
      <guid>https://gpavolini.netlify.com/blog/data-table-joins-is-x-y-or-y-x/</guid>
      <description>This is intended to be a very short post, an often-revisited reminder of the syntax for joins in data.table.
When doing joins in data.table I often have to open a new R session and run the next code:
a &amp;lt;- data.table(x = 1:3, y = 2:4) b &amp;lt;- data.table(x = 2:5, z = 3:6) a[b, on = .(x)] ## x y z ## 1: 2 3 3 ## 2: 3 4 4 ## 3: 4 NA 5 ## 4: 5 NA 6 in order to realize that the look-up table was a and not b.</description>
    </item>
    
    <item>
      <title>Using dcast and setnames **inside** a data.table</title>
      <link>https://gpavolini.netlify.com/blog/using-dcast-and-setnames-inside-a-data-table/</link>
      <pubDate>Mon, 04 Nov 2019 00:00:00 +0000</pubDate>
      
      <guid>https://gpavolini.netlify.com/blog/using-dcast-and-setnames-inside-a-data-table/</guid>
      <description>I’ve said before that one of the best things of data.table is that J takes in expressions and not only functions. That offers so much flexibility in what you can achieve with your code.
Also, the fact that .SD is a data.table allows you to use inside a data.table some functions that apparently should be used outside of it.
Take for example dcast, the function used to reshape a data.</description>
    </item>
    
    <item>
      <title>Long to Wide and Wide to Long Format Conversion</title>
      <link>https://gpavolini.netlify.com/blog/long-to-wide-and-wide-to-long-format-conversion/</link>
      <pubDate>Mon, 22 Jul 2019 00:00:00 +0000</pubDate>
      
      <guid>https://gpavolini.netlify.com/blog/long-to-wide-and-wide-to-long-format-conversion/</guid>
      <description>¡Mirá una versión en español aquí!
One of the difficulties I find most often in Stack Overflow questions about R, an in general about data science, is the erroneous usage of wide formats for data analysis.
In this post we’ll se some functions of the data.table package in R to convert from wide to long format and vice versa.
Different Ways to Store the Same Data There are two possible ways of storing tabulated data: in a “wide” format, and in a “long” format.</description>
    </item>
    
    <item>
      <title>data.table&#39;s `cube` function</title>
      <link>https://gpavolini.netlify.com/blog/data-table-s-cube-function/</link>
      <pubDate>Fri, 19 Jul 2019 00:00:00 +0000</pubDate>
      
      <guid>https://gpavolini.netlify.com/blog/data-table-s-cube-function/</guid>
      <description>Recently I learned there’s a cube function in data.table, thanks to Dan Wilson:
Just came across data.table::cube() which aggregates and includes a total. I don’t know how I’ve never known about this function before #datatable #rstats
e.g. cube(mtcars,
.(mean_disp = mean(disp)),
by = c(“cyl”)) — Dan Wilson (@danwwilson) July 18, 2019   Perhaps I should allocate a time to just do [packageName]:: and keep hitting TAB in RStudio to learn about the many nice functions the packages I use often have, and I don’t know.</description>
    </item>
    
  </channel>
</rss>